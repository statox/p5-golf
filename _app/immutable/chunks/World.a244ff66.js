var _=Object.defineProperty;var k=(g,t,o)=>t in g?_(g,t,{enumerable:!0,configurable:!0,writable:!0,value:o}):g[t]=o;var l=(g,t,o)=>(k(g,typeof t!="symbol"?t+"":t,o),o);import{V as f}from"./PhysicObject.d0894205.js";class M{constructor(){l(this,"apply",(t,o)=>{const i=this.bounce(t,o),n=this.pullApart(t,o);return{...i,...n}});l(this,"intersectionPoint",(t,o)=>{if(o.geometry.type!=="sphere"||t.geometry.type!=="line")throw new Error("invalid geometry");const i=t.position.clone(),n=t.position.clone().add(t.geometry.vector),e=o.position.clone(),s=o.geometry.r,c=n.clone().subtract(i),r=i.clone().subtract(e),y=c.dot(c),d=r.dot(c)*2,h=r.dot(r)-s*s;let u=d*d-4*y*h;if(u<0)return;u=Math.sqrt(u);const m=(-d-u)/(2*y),a=(-d+u)/(2*y),p=m>=0&&m<=1,N=a>=0&&a<=1;if(p&&N)return i.add(c.multiplyScalar(m+(a-m)*.5));if(p)return i.add(c.multiplyScalar(m+(1-m)*.5));if(N)return i.add(c.multiplyScalar(a*.5))});l(this,"bounce",(t,o)=>{if(o.geometry.type!=="sphere"||t.geometry.type!=="line")throw new Error("invalid geometry");const i=this.intersectionPoint(t,o);if(!i)return;const n=t.restitution*o.restitution,e=t.friction*o.friction,s=t.position.x,c=t.position.y,r=t.position.x+t.geometry.vector.x,y=t.position.y+t.geometry.vector.y,d=o.position.x,h=o.position.y,u=o.position.x+o.velocity.x,m=o.position.y+o.velocity.y;let a=(y-c)/(r-s),p=(m-h)/(u-d);if(a=[1/0,-1/0].includes(a)?360:a,p=[1/0,-1/0].includes(p)?360:p,(a-p)/(1+a*p)===0){const A=n,G=e;return{bouncedVelocity:o.velocity.multiplyScalar(1-G).multiplyScalar(-A),intersection:i}}const S=r-s,w=y-c,x=new f(-w,S),C=new f(w,-S),P=i.clone().add(x),q=i.clone().add(C);let b;o.position.distanceSq(P)<o.position.distanceSq(q)?b=x:b=C;const V=b.clone().normalize(),E=o.velocity.clone(),T=V.multiplyScalar(E.dot(V)),I=E.subtract(T),j=n,D=e;return{bouncedVelocity:I.multiplyScalar(1-D).subtract(T.multiplyScalar(j)),intersection:i}});l(this,"pullApart",(t,o)=>{if(o.geometry.type!=="sphere"||t.geometry.type!=="line")throw new Error("invalid geometry");const i=this.intersectionPoint(t,o);if(!i)return;const n=o.position.clone().subtract(i),e=n.length();if(e>o.geometry.r)return{positionCorrection:new f(0,0)};const c=o.geometry.r-e;return{positionCorrection:n.normalize().multiplyScalar(c)}})}}class O{constructor(){l(this,"apply",(t,o)=>({...this.pullApart(t,o),...this.bounce(t,o)}));l(this,"intersectionPoint",(t,o)=>{if(t.geometry.type!=="sphere"||o.geometry.type!=="sphere")return;const i=t.geometry.r,n=o.geometry.r,e=t.position.distanceSq(o.position),s=(i+n)**2;if(e>s)return;const c=o.position.clone().subtract(t.position),r=i/(i+n);return c.multiplyScalar(r),t.position.clone().add(c)});l(this,"bounce",(t,o)=>{if(t.geometry.type!=="sphere"||o.geometry.type!=="sphere")throw new Error("invalid geometry");const i=this.intersectionPoint(t,o);if(!i)return;const n=t.restitution*o.restitution,e=t.friction*o.friction,s=o.position.x,c=o.position.y,r=o.position.x+o.velocity.x,y=o.position.y+o.velocity.y,d=t.position.x,h=t.position.y,u=t.position.x+t.velocity.x,m=t.position.y+t.velocity.y;let a=(y-c)/(r-s),p=(m-h)/(u-d);if(a=[1/0,-1/0].includes(a)?360:a,p=[1/0,-1/0].includes(p)?360:p,(a-p)/(1+a*p)===0){const A=n,G=e;return{bouncedVelocity:t.velocity.multiplyScalar(1-G).multiplyScalar(-A),intersection:i}}const S=r-s,w=y-c,x=new f(-w,S),C=new f(w,-S),P=i.clone().add(x),q=i.clone().add(C);let b;t.position.distanceSq(P)<t.position.distanceSq(q)?b=x:b=C;const V=b.clone().normalize(),E=t.velocity.clone(),T=V.multiplyScalar(E.dot(V)),I=E.subtract(T),j=n,D=e;return{bouncedVelocity:I.multiplyScalar(1-D).subtract(T.multiplyScalar(j)),intersection:i}});l(this,"pullApart",(t,o)=>{if(t.geometry.type!=="sphere"||o.geometry.type!=="sphere")throw new Error("invalid geometry");const i=this.intersectionPoint(t,o);if(!i)return;const n=t.position.clone().subtract(i),e=n.length(),s=t.geometry.r-e;return n.normalize().multiplyScalar(s),{positionCorrection:n}})}}const B=new M,H=new O;class Q{constructor(t){l(this,"gravityEnabled");l(this,"dimensions");l(this,"t");l(this,"objects");l(this,"gravity",new f(0,-9.8));l(this,"antiGravity",new f(0,9.8));l(this,"drag",.001);l(this,"dt",.005);l(this,"reporter");this.gravityEnabled=t.enableGravity??!0,this.dimensions=t.dimensions||new f(100,100),this.objects=[],this.t=0,this.reporter=t.reporter||console.log}toggleGravity(){this.gravityEnabled=!this.gravityEnabled}addObject(t){this.objects.push(t)}applyGravity(t){t.acceleration.push(this.gravity)}applyForce(t,o){t.acceleration.push(o)}applyDynamics(t,o){if(o.fixed)return;this.gravityEnabled&&this.applyGravity(o);const i=new f(0,0);for(;o.acceleration.length;){const e=o.acceleration.pop();e&&i.add(e)}i.divideScalar(o.m);const n=1-this.drag;o.velocity.add(i.multiplyScalar(t)).multiplyScalar(n),o.position.add(o.velocity.clone().multiplyScalar(t))}applyCollisions(t){const o=this.objects.filter(n=>n.geometry.type==="sphere"),i=this.objects.filter(n=>n.geometry.type==="line");for(let n=0;n<o.length;n++){const e=o[n];e.data.isColliding=!1;const s=new f(0,0);let c=0;for(const r of i){r.data.isColliding=!1;const y=B.apply(r,e);if(!y.intersection)continue;const{bouncedVelocity:d,positionCorrection:h}=y;r.data.isColliding=!0,r.collisionListener(),c++,s.add(d),e.position.add(h)}for(let r=0;r<o.length;r++){if(n===r)continue;const y=o[r],d=H.apply(e,y);if(!d.intersection)continue;const{bouncedVelocity:h,positionCorrection:u}=d;c++,s.add(h),e.position.add(u)}c>0&&(s.divideScalar(c),e.velocity.copy(s),e.position.add(e.velocity.clone().multiplyScalar(t)),e.data.isColliding=!0,e.collisionListener(),e.acceleration.push(this.antiGravity))}}_step(t){this.applyCollisions(t);for(const o of this.objects)this.applyDynamics(t,o)}stepFixedDt(){const o=Date.now()/1e3;W=o-v,v=o,this._step(.01),this.t+=.01,this.reporter&&this.reporter({...this,frameTime:W})}stepAccumulator(){const t=this.dt,o=Date.now()/1e3;v===0&&(v=o),W=o-v,v=o,L+=W;let i=0;for(;L>=t&&i<5;)i++,this._step(t),L-=t,this.t+=t,this.reporter&&this.reporter({...this,frameTime:W})}step(){this.stepAccumulator()}}let v=0,W=0,L=0;export{M as L,O as S,Q as W};
