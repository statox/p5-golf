var L=Object.defineProperty;var B=(m,t,o)=>t in m?L(m,t,{enumerable:!0,configurable:!0,writable:!0,value:o}):m[t]=o;var l=(m,t,o)=>(B(m,typeof t!="symbol"?t+"":t,o),o);import{V as h}from"./p5utils.9a0390ea.js";class k{constructor(){l(this,"apply",(t,o)=>{const i=this.bounce(t,o),n=this.pullApart(t,o);return{...i,...n}});l(this,"intersectionPoint",(t,o)=>{if(o.geometry.type!=="sphere"||t.geometry.type!=="line")throw new Error("invalid geometry");const i=t.position.clone(),n=t.position.clone().add(t.geometry.vector),e=o.position.clone(),s=o.geometry.r,r=n.clone().subtract(i),c=i.clone().subtract(e),a=r.dot(r),p=c.dot(r)*2,b=c.dot(c)-s*s;let f=p*p-4*a*b;if(f<0)return;f=Math.sqrt(f);const u=(-p-f)/(2*a),d=(-p+f)/(2*a),y=u>=0&&u<=1,I=d>=0&&d<=1;if(y&&I)return i.add(r.multiplyScalar(u+(d-u)*.5));if(y)return i.add(r.multiplyScalar(u+(1-u)*.5));if(I)return i.add(r.multiplyScalar(d*.5))});l(this,"bounce",(t,o)=>{if(o.geometry.type!=="sphere"||t.geometry.type!=="line")throw new Error("invalid geometry");const i=this.intersectionPoint(t,o);if(!i)return;const n=t.restitution*o.restitution,e=t.friction*o.friction,s=t.position.x,r=t.position.y,c=t.position.x+t.geometry.vector.x,a=t.position.y+t.geometry.vector.y,p=o.position.x,b=o.position.y,f=o.position.x+o.velocity.x,u=o.position.y+o.velocity.y;let d=(a-r)/(c-s),y=(u-b)/(f-p);if(d=[1/0,-1/0].includes(d)?360:d,y=[1/0,-1/0].includes(y)?360:y,(d-y)/(1+d*y)===0){const q=n,D=e;return{bouncedVelocity:o.velocity.multiplyScalar(1-D).multiplyScalar(-q),intersection:i}}const S=c-s,x=a-r,w=new h(-x,S),j=new h(x,-S),T=i.clone().add(w),W=i.clone().add(j);let g;o.position.distanceSq(T)<o.position.distanceSq(W)?g=w:g=j;const C=g.clone().normalize(),V=o.velocity.clone(),E=C.multiplyScalar(V.dot(C)),M=V.subtract(E),N=n,P=e;return{bouncedVelocity:M.multiplyScalar(1-P).subtract(E.multiplyScalar(N)),intersection:i}});l(this,"pullApart",(t,o)=>{if(o.geometry.type!=="sphere"||t.geometry.type!=="line")throw new Error("invalid geometry");const i=this.intersectionPoint(t,o);if(!i)return;const n=o.position.clone().subtract(i),e=n.length();if(e>o.geometry.r)return;const s=o.geometry.r-e;return{positionCorrection:n.normalize().multiplyScalar(s)}})}}class H{constructor(){l(this,"apply",(t,o)=>({...this.pullApart(t,o),...this.bounce(t,o)}));l(this,"intersectionPoint",(t,o)=>{if(t.geometry.type!=="sphere"||o.geometry.type!=="sphere")return;const i=t.geometry.r,n=o.geometry.r,e=t.position.distanceSq(o.position),s=(i+n)**2;if(e>s)return;const r=o.position.clone().subtract(t.position),c=i/(i+n);return r.multiplyScalar(c),t.position.clone().add(r)});l(this,"bounce",(t,o)=>{if(t.geometry.type!=="sphere"||o.geometry.type!=="sphere")throw new Error("invalid geometry");const i=this.intersectionPoint(t,o);if(!i)return;const n=t.restitution*o.restitution,e=t.friction*o.friction,s=o.position.x,r=o.position.y,c=o.position.x+o.velocity.x,a=o.position.y+o.velocity.y,p=t.position.x,b=t.position.y,f=t.position.x+t.velocity.x,u=t.position.y+t.velocity.y;let d=(a-r)/(c-s),y=(u-b)/(f-p);if(d=[1/0,-1/0].includes(d)?360:d,y=[1/0,-1/0].includes(y)?360:y,(d-y)/(1+d*y)===0){const q=n,D=e;return{bouncedVelocity:t.velocity.multiplyScalar(1-D).multiplyScalar(-q),intersection:i}}const S=c-s,x=a-r,w=new h(-x,S),j=new h(x,-S),T=i.clone().add(w),W=i.clone().add(j);let g;t.position.distanceSq(T)<t.position.distanceSq(W)?g=w:g=j;const C=g.clone().normalize(),V=t.velocity.clone(),E=C.multiplyScalar(V.dot(C)),M=V.subtract(E),N=n,P=e;return{bouncedVelocity:M.multiplyScalar(1-P).subtract(E.multiplyScalar(N)),intersection:i}});l(this,"pullApart",(t,o)=>{if(t.geometry.type!=="sphere"||o.geometry.type!=="sphere")throw new Error("invalid geometry");const i=this.intersectionPoint(t,o);if(!i)return;const n=t.position.clone().subtract(i),e=n.length(),s=t.geometry.r-e;return n.normalize().multiplyScalar(s),{positionCorrection:n}})}}const z=new k,G=new H;class Q{constructor(t){l(this,"gravityEnabled");l(this,"collisionEnabled");l(this,"overlapsAllowed");l(this,"dimensions");l(this,"t");l(this,"objects");l(this,"gravity",new h(0,-9.8));l(this,"antiGravity",new h(0,9.8));l(this,"drag",.001);l(this,"dt",.005);l(this,"reporter");l(this,"bordersMode");this.collisionEnabled=t.enableCollisions??!0,this.gravityEnabled=t.enableGravity??!0,this.overlapsAllowed=t.enableOverlaps??!1,this.dimensions=t.dimensions||new h(100,100),this.objects=[],this.t=0,this.reporter=t.reporter||(()=>{}),this.drag=t.drag??this.drag,this.bordersMode=t.bordersMode??"none"}toggleGravity(){this.gravityEnabled=!this.gravityEnabled}addObject(t){const o=this.objects.reduce((i,n)=>i>n.data.id?i:n.data.id,0);return t.data.id=o+1,this.objects.push(t),t}addObjects(t){return t.forEach(o=>this.addObject(o)),this.objects}removeObject(t){if(t.data.id===-1)throw new Error("Cant remove an object with uninitialized id");const o=this.objects.findIndex(i=>i.data.id===t.data.id);if(o===-1)throw new Error("Object not found in world");this.objects.splice(o,1)}applyGravity(t){t.acceleration.push(this.gravity)}applyForce(t,o){t.acceleration.push(o)}applyDynamics(t,o){if(o.fixed)return;this.gravityEnabled&&this.applyGravity(o);const i=new h(0,0);for(;o.acceleration.length;){const e=o.acceleration.pop();e&&i.add(e)}i.divideScalar(o.m);const n=1-this.drag;o.velocity.add(i.multiplyScalar(t)).multiplyScalar(n),o.position.add(o.velocity.clone().multiplyScalar(t))}applyCollisions(t){var i,n;const o=new Array(this.objects.length).fill(0).map(e=>({totalVelocity:new h(0,0),nbCollisions:0}));for(let e=0;e<this.objects.length;e++){const s=this.objects[e];if(!s.fixed){s.data.isColliding=!1;for(let r=0;r<this.objects.length;r++){if(e===r)continue;const c=this.objects[r];if(s.geometry.type==="line"&&c.geometry.type==="line")continue;let a;if(s.geometry.type==="sphere"&&c.geometry.type==="sphere")a=(i=G.bounce(s,c))==null?void 0:i.bouncedVelocity;else{const p=s.geometry.type==="line"?s:c,b=s.geometry.type==="line"?c:s;a=(n=z.bounce(p,b))==null?void 0:n.bouncedVelocity}a&&(o[e].totalVelocity.add(a),o[e].nbCollisions++)}}}for(let e=0;e<this.objects.length;e++){const{totalVelocity:s,nbCollisions:r}=o[e];if(r===0)continue;const c=this.objects[e];s.divideScalar(r),c.velocity.copy(s),c.position.add(c.velocity.clone().multiplyScalar(t)),c.data.isColliding=!0,c.collisionListener()}}preventOverlaps(t){var o,i;for(let n=0;n<this.objects.length;n++){const e=this.objects[n];if(!e.fixed)for(let s=0;s<this.objects.length;s++){if(n===s)continue;const r=this.objects[s];if(e.geometry.type==="line"&&r.geometry.type==="line")continue;let c;if(e.geometry.type==="sphere"&&r.geometry.type==="sphere")c=(o=G.pullApart(e,r))==null?void 0:o.positionCorrection;else{const a=e.geometry.type==="line"?e:r,p=e.geometry.type==="line"?r:e;c=(i=z.pullApart(a,p))==null?void 0:i.positionCorrection}c&&(e.position.add(c.divideScalar(t).divideScalar(2)),r.fixed||r.position.add(c.divideScalar(t).divideScalar(2).multiplyScalar(-1)))}}}enforceBordersMode(){if(this.bordersMode!=="none"){if(this.bordersMode==="wrap")for(const t of this.objects)t.position.x<0&&(t.position.x=this.dimensions.x+t.position.x),t.position.y<0&&(t.position.y=this.dimensions.y+t.position.y),t.position.x>this.dimensions.x&&(t.position.x=t.position.x-this.dimensions.x),t.position.y>this.dimensions.y&&(t.position.y=t.position.y-this.dimensions.y);if(this.bordersMode==="hard")for(const t of this.objects)t.position.x<0&&(t.position.x=0),t.position.y<0&&(t.position.y=0),t.position.x>this.dimensions.x&&(t.position.x=this.dimensions.x),t.position.y>this.dimensions.y&&(t.position.y=this.dimensions.y)}}_step(t){for(const o of this.objects)this.applyDynamics(t,o),o.data.age++;if(!this.overlapsAllowed)for(let i=0;i<1;i++)this.preventOverlaps(1);this.collisionEnabled&&this.applyCollisions(t),this.bordersMode!=="none"&&this.enforceBordersMode()}stepFixedDt(){const o=Date.now()/1e3;A=o-v,v=o,this._step(.01),this.t+=.01,this.reporter&&this.reporter({...this,frameTime:A})}stepAccumulator(){const t=this.dt,o=Date.now()/1e3;v===0&&(v=o),A=o-v,v=o,O+=A;let i=0;for(;O>=t&&i<5;)i++,this._step(t),O-=t,this.t+=t,this.reporter&&this.reporter({...this,frameTime:A})}step(){this.stepAccumulator()}}let v=0,A=0,O=0;export{H as S,Q as W};
