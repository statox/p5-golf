var F=Object.defineProperty;var _=(m,o,t)=>o in m?F(m,o,{enumerable:!0,configurable:!0,writable:!0,value:t}):m[o]=t;var c=(m,o,t)=>(_(m,typeof o!="symbol"?o+"":o,t),t);import{V as f}from"./PhysicObject.d0894205.js";class z{constructor(){c(this,"apply",(o,t)=>{const i=this.bounce(o,t),n=this.pullApart(o,t);return{...i,...n}});c(this,"intersectionPoint",(o,t)=>{if(t.geometry.type!=="sphere"||o.geometry.type!=="line")throw new Error("invalid geometry");const i=o.position.clone(),n=o.position.clone().add(o.geometry.vector),s=t.position.clone(),l=t.geometry.r,e=n.clone().subtract(i),a=i.clone().subtract(s),d=e.dot(e),p=a.dot(e)*2,v=a.dot(a)-l*l;let g=p*p-4*d*v;if(g<0)return;g=Math.sqrt(g);const y=(-p-g)/(2*d),r=(-p+g)/(2*d),u=y>=0&&y<=1,w=r>=0&&r<=1;if(console.log(y+(r-y)*.5),u&&w)return i.add(e.multiplyScalar(y+(r-y)*.5));if(u)return i.add(e.multiplyScalar(y+(1-y)*.5));if(w)return i.add(e.multiplyScalar(r*.5))});c(this,"bounce",(o,t)=>{if(t.geometry.type!=="sphere"||o.geometry.type!=="line")throw new Error("invalid geometry");const i=this.intersectionPoint(o,t);if(!i)return;const n=o.restitution*t.restitution,s=o.friction*t.friction,l=o.position.x,e=o.position.y,a=o.position.x+o.geometry.vector.x,d=o.position.y+o.geometry.vector.y,p=t.position.x,v=t.position.y,g=t.position.x+t.velocity.x,y=t.position.y+t.velocity.y;let r=(d-e)/(a-l),u=(y-v)/(g-p);if(r=[1/0,-1/0].includes(r)?360:r,u=[1/0,-1/0].includes(u)?360:u,(r-u)/(1+r*u)===0){const I=n,q=s;return{bouncedVelocity:t.velocity.multiplyScalar(1-q).multiplyScalar(-I),intersection:i}}const x=a-l,V=d-e,E=new f(-V,x),j=new f(V,-x),G=i.clone().add(E),A=i.clone().add(j);let S;t.position.distanceSq(G)<t.position.distanceSq(A)?S=E:S=j;const T=S.clone().normalize(),W=t.velocity.clone(),D=T.multiplyScalar(W.dot(T)),L=W.subtract(D),N=n,P=s;return{bouncedVelocity:L.multiplyScalar(1-P).subtract(D.multiplyScalar(N)),intersection:i}});c(this,"pullApart",(o,t)=>{if(t.geometry.type!=="sphere"||o.geometry.type!=="line")throw new Error("invalid geometry");const i=this.intersectionPoint(o,t);if(!i)return;const n=t.position.clone().subtract(i),s=n.length();if(s>t.geometry.r)return{positionCorrection:new f(0,0)};const e=t.geometry.r-s;return{positionCorrection:n.normalize().multiplyScalar(e)}})}}const k=new z;class J{constructor(o){c(this,"gravityEnabled");c(this,"dimensions");c(this,"t");c(this,"objects");c(this,"gravity",new f(0,-9.8));c(this,"antiGravity",new f(0,9.8));c(this,"drag",.001);c(this,"dt",.005);c(this,"reporter");this.gravityEnabled=o.enableGravity??!0,this.dimensions=o.dimensions||new f(100,100),this.objects=[],this.t=0,this.reporter=o.reporter||console.log}toggleGravity(){this.gravityEnabled=!this.gravityEnabled}addObject(o){this.objects.push(o)}applyGravity(o){o.acceleration.push(this.gravity)}applyForce(o,t){o.acceleration.push(t)}applyDynamics(o,t){if(t.fixed)return;this.gravityEnabled&&this.applyGravity(t);const i=new f(0,0);for(;t.acceleration.length;){const s=t.acceleration.pop();s&&i.add(s)}i.divideScalar(t.m);const n=1-this.drag;t.velocity.add(i.multiplyScalar(o)).multiplyScalar(n),t.position.add(t.velocity.clone().multiplyScalar(o))}applyCollisions(o){const t=this.objects.filter(n=>n.geometry.type==="sphere"),i=this.objects.filter(n=>n.geometry.type==="line");for(const n of t){n.data.isColliding=!1;const s=new f(0,0);let l=0;for(const e of i){e.data.isColliding=!1;const a=k.apply(e,n);if(!a.intersection)continue;const{bouncedVelocity:d,positionCorrection:p}=a;e.data.isColliding=!0,e.collisionListener(),l++,s.add(d),n.position.add(p)}l>0&&(s.divideScalar(l),n.velocity.copy(s),n.position.add(n.velocity.clone().multiplyScalar(o)),n.data.isColliding=!0,n.collisionListener(),n.acceleration.push(this.antiGravity))}}_step(o){this.applyCollisions(o);for(const t of this.objects)this.applyDynamics(o,t)}stepFixedDt(){const t=Date.now()/1e3;b=t-h,h=t,this._step(.01),this.t+=.01,this.reporter&&this.reporter({...this,frameTime:b})}stepAccumulator(){const o=this.dt,t=Date.now()/1e3;h===0&&(h=t),b=t-h,h=t,C+=b;let i=0;for(;C>=o&&i<5;)i++,this._step(o),C-=o,this.t+=o,this.reporter&&this.reporter({...this,frameTime:b})}step(){this.stepAccumulator()}}let h=0,b=0,C=0;export{z as L,J as W};
