var O=Object.defineProperty;var _=(b,t,o)=>t in b?O(b,t,{enumerable:!0,configurable:!0,writable:!0,value:o}):b[t]=o;var s=(b,t,o)=>(_(b,typeof t!="symbol"?t+"":t,o),o);import{V as f}from"./PhysicObject.edd17eee.js";class k{constructor(){s(this,"apply",(t,o)=>{const i=this.bounce(t,o),n=this.pullApart(t,o);return{...i,...n}});s(this,"intersectionPoint",(t,o)=>{if(o.geometry.type!=="sphere"||t.geometry.type!=="line")throw new Error("invalid geometry");const i=t.position.clone(),n=t.position.clone().add(t.geometry.vector),e=o.position.clone(),l=o.geometry.r,c=n.clone().subtract(i),r=i.clone().subtract(e),y=c.dot(c),p=r.dot(c)*2,h=r.dot(r)-l*l;let u=p*p-4*y*h;if(u<0)return;u=Math.sqrt(u);const m=(-p-u)/(2*y),a=(-p+u)/(2*y),d=m>=0&&m<=1,T=a>=0&&a<=1;if(d&&T)return i.add(c.multiplyScalar(m+(a-m)*.5));if(d)return i.add(c.multiplyScalar(m+(1-m)*.5));if(T)return i.add(c.multiplyScalar(a*.5))});s(this,"bounce",(t,o)=>{if(o.geometry.type!=="sphere"||t.geometry.type!=="line")throw new Error("invalid geometry");const i=this.intersectionPoint(t,o);if(!i)return;const n=t.restitution*o.restitution,e=t.friction*o.friction,l=t.position.x,c=t.position.y,r=t.position.x+t.geometry.vector.x,y=t.position.y+t.geometry.vector.y,p=o.position.x,h=o.position.y,u=o.position.x+o.velocity.x,m=o.position.y+o.velocity.y;let a=(y-c)/(r-l),d=(m-h)/(u-p);if(a=[1/0,-1/0].includes(a)?360:a,d=[1/0,-1/0].includes(d)?360:d,(a-d)/(1+a*d)===0){const A=n,G=e;return{bouncedVelocity:o.velocity.multiplyScalar(1-G).multiplyScalar(-A),intersection:i}}const w=r-l,S=y-c,x=new f(-S,w),C=new f(S,-w),W=i.clone().add(x),N=i.clone().add(C);let g;o.position.distanceSq(W)<o.position.distanceSq(N)?g=x:g=C;const V=g.clone().normalize(),E=o.velocity.clone(),j=V.multiplyScalar(E.dot(V)),P=E.subtract(j),q=n,D=e;return{bouncedVelocity:P.multiplyScalar(1-D).subtract(j.multiplyScalar(q)),intersection:i}});s(this,"pullApart",(t,o)=>{if(o.geometry.type!=="sphere"||t.geometry.type!=="line")throw new Error("invalid geometry");const i=this.intersectionPoint(t,o);if(!i)return;const n=o.position.clone().subtract(i),e=n.length();if(e>o.geometry.r)return{positionCorrection:new f(0,0)};const c=o.geometry.r-e;return{positionCorrection:n.normalize().multiplyScalar(c)}})}}class M{constructor(){s(this,"apply",(t,o)=>({...this.pullApart(t,o),...this.bounce(t,o)}));s(this,"intersectionPoint",(t,o)=>{if(t.geometry.type!=="sphere"||o.geometry.type!=="sphere")return;const i=t.geometry.r,n=o.geometry.r,e=t.position.distanceSq(o.position),l=(i+n)**2;if(e>l)return;const c=o.position.clone().subtract(t.position),r=i/(i+n);return c.multiplyScalar(r),t.position.clone().add(c)});s(this,"bounce",(t,o)=>{if(t.geometry.type!=="sphere"||o.geometry.type!=="sphere")throw new Error("invalid geometry");const i=this.intersectionPoint(t,o);if(!i)return;const n=t.restitution*o.restitution,e=t.friction*o.friction,l=o.position.x,c=o.position.y,r=o.position.x+o.velocity.x,y=o.position.y+o.velocity.y,p=t.position.x,h=t.position.y,u=t.position.x+t.velocity.x,m=t.position.y+t.velocity.y;let a=(y-c)/(r-l),d=(m-h)/(u-p);if(a=[1/0,-1/0].includes(a)?360:a,d=[1/0,-1/0].includes(d)?360:d,(a-d)/(1+a*d)===0){const A=n,G=e;return{bouncedVelocity:t.velocity.multiplyScalar(1-G).multiplyScalar(-A),intersection:i}}const w=r-l,S=y-c,x=new f(-S,w),C=new f(S,-w),W=i.clone().add(x),N=i.clone().add(C);let g;t.position.distanceSq(W)<t.position.distanceSq(N)?g=x:g=C;const V=g.clone().normalize(),E=t.velocity.clone(),j=V.multiplyScalar(E.dot(V)),P=E.subtract(j),q=n,D=e;return{bouncedVelocity:P.multiplyScalar(1-D).subtract(j.multiplyScalar(q)),intersection:i}});s(this,"pullApart",(t,o)=>{if(t.geometry.type!=="sphere"||o.geometry.type!=="sphere")throw new Error("invalid geometry");const i=this.intersectionPoint(t,o);if(!i)return;const n=t.position.clone().subtract(i),e=n.length(),l=t.geometry.r-e;return n.normalize().multiplyScalar(l),{positionCorrection:n}})}}const B=new k,H=new M;class Q{constructor(t){s(this,"gravityEnabled");s(this,"collisionEnabled");s(this,"dimensions");s(this,"t");s(this,"objects");s(this,"gravity",new f(0,-9.8));s(this,"antiGravity",new f(0,9.8));s(this,"drag",.001);s(this,"dt",.005);s(this,"reporter");this.collisionEnabled=t.enableCollisions??!0,this.gravityEnabled=t.enableGravity??!0,this.dimensions=t.dimensions||new f(100,100),this.objects=[],this.t=0,this.reporter=t.reporter||(()=>{})}toggleGravity(){this.gravityEnabled=!this.gravityEnabled}addObject(t){const o=this.objects.reduce((i,n)=>i>n.data.id?i:n.data.id,0);t.data.id=o+1,this.objects.push(t)}removeObject(t){if(t.data.id===-1)throw new Error("Cant remove an object with uninitialized id");const o=this.objects.findIndex(i=>i.data.id===t.data.id);if(o===-1)throw new Error("Object not found in world");this.objects.splice(o,1)}applyGravity(t){t.acceleration.push(this.gravity)}applyForce(t,o){t.acceleration.push(o)}applyDynamics(t,o){if(o.fixed)return;this.gravityEnabled&&this.applyGravity(o);const i=new f(0,0);for(;o.acceleration.length;){const e=o.acceleration.pop();e&&i.add(e)}i.divideScalar(o.m);const n=1-this.drag;o.velocity.add(i.multiplyScalar(t)).multiplyScalar(n),o.position.add(o.velocity.clone().multiplyScalar(t))}applyCollisions(t){const o=this.objects.filter(n=>n.geometry.type==="sphere"),i=this.objects.filter(n=>n.geometry.type==="line");for(let n=0;n<o.length;n++){const e=o[n];e.data.isColliding=!1;const l=new f(0,0);let c=0;for(const r of i){r.data.isColliding=!1;const y=B.apply(r,e);if(!y.intersection)continue;const{bouncedVelocity:p,positionCorrection:h}=y;r.data.isColliding=!0,r.collisionListener(),c++,l.add(p),e.position.add(h)}for(let r=0;r<o.length;r++){if(n===r)continue;const y=o[r],p=H.apply(e,y);if(!p.intersection)continue;const{bouncedVelocity:h,positionCorrection:u}=p;c++,l.add(h),e.position.add(u)}c>0&&(l.divideScalar(c),e.velocity.copy(l),e.position.add(e.velocity.clone().multiplyScalar(t)),e.data.isColliding=!0,e.collisionListener(),e.acceleration.push(this.antiGravity))}}_step(t){this.collisionEnabled&&this.applyCollisions(t);for(const o of this.objects)this.applyDynamics(t,o),o.data.age++}stepFixedDt(){const o=Date.now()/1e3;I=o-v,v=o,this._step(.01),this.t+=.01,this.reporter&&this.reporter({...this,frameTime:I})}stepAccumulator(){const t=this.dt,o=Date.now()/1e3;v===0&&(v=o),I=o-v,v=o,z+=I;let i=0;for(;z>=t&&i<5;)i++,this._step(t),z-=t,this.t+=t,this.reporter&&this.reporter({...this,frameTime:I})}step(){this.stepAccumulator()}}let v=0,I=0,z=0;export{k as L,M as S,Q as W};
