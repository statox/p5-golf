var W=Object.defineProperty;var D=(e,o,t)=>o in e?W(e,o,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[o]=t;var r=(e,o,t)=>(D(e,typeof o!="symbol"?o+"":o,t),t);import{V as d}from"./p5utils.fe4d08ff.js";const G=(e,o)=>{if(o.geometry.type!=="sphere"||e.geometry.type!=="line")throw new Error("invalid geometry");const t=N(e,o);if(!t)return;const s=e.restitution*o.restitution,l=e.friction*o.friction,n=e.position.x,i=e.position.y,y=e.position.x+e.geometry.vector.x,m=e.position.y+e.geometry.vector.y,a=y-n,p=m-i,c=new d(-p,a),f=new d(p,-a),u=t.clone().add(c),w=t.clone().add(f);let h;o.position.distanceSq(u)<o.position.distanceSq(w)?h=c:h=f;const S=h.clone().normalize(),C=o.velocity.clone(),x=S.multiplyScalar(C.dot(S)),E=C.subtract(x),j=s,V=l;return{bouncedVelocity:E.multiplyScalar(1-V).subtract(x.multiplyScalar(j)),intersection:t}},N=(e,o)=>{if(o.geometry.type!=="sphere"||e.geometry.type!=="line")throw new Error("invalid geometry");const t=e.position.clone(),s=e.position.clone().add(e.geometry.vector),l=o.position.clone(),n=o.geometry.r,i=s.clone().subtract(t),y=t.clone().subtract(l),m=i.dot(i),a=y.dot(i)*2,p=y.dot(y)-n*n;let c=a*a-4*m*p;if(c<0)return;c=Math.sqrt(c);const f=(-a-c)/(2*m),u=(-a+c)/(2*m),w=f>=0&&f<=1,h=u>=0&&u<=1;if(w&&h)return t.add(i.multiplyScalar(f+(u-f)*.5));if(w)return t.add(i.multiplyScalar(1));if(h)return t.add(i.multiplyScalar(0))};class F{constructor(o){r(this,"gravityEnabled");r(this,"dimensions");r(this,"t");r(this,"objects");r(this,"gravity",new d(0,-9.8));r(this,"antiGravity",new d(0,9.8));r(this,"drag",.001);r(this,"dt",.005);r(this,"reporter");this.gravityEnabled=o.enableGravity??!0,this.dimensions=o.dimensions||new d(100,100),this.objects=[],this.t=0,this.reporter=o.reporter||console.log}toggleGravity(){this.gravityEnabled=!this.gravityEnabled}addObject(o){this.objects.push(o)}applyGravity(o){o.acceleration.push(this.gravity)}applyForce(o,t){o.acceleration.push(t)}applyDynamics(o,t){this.gravityEnabled&&this.applyGravity(t);const s=new d(0,0);for(;t.acceleration.length;){const n=t.acceleration.pop();n&&s.add(n)}s.divideScalar(t.m);const l=1-this.drag;t.velocity.add(s.multiplyScalar(o)).multiplyScalar(l),t.position.add(t.velocity.clone().multiplyScalar(o))}applyCollisions(o){const t=this.objects.find(i=>i.geometry.type==="sphere"),s=this.objects.filter(i=>i.geometry.type==="line");if(!t)throw new Error("No sphere in world");t.data.isColliding=!1;const l=new d(0,0);let n=0;for(const i of s){i.data.isColliding=!1;const y=G(i,t);if(!y)continue;const{bouncedVelocity:m,intersection:a}=y;i.data.isColliding=!0,n++,l.add(m);const p=t.position.clone().subtract(a),c=p.length();if(c<=t.geometry.r){const u=t.geometry.r-c;p.normalize().multiplyScalar(u),t.position.add(p)}}n>0&&(l.divideScalar(n),t.velocity.copy(l),t.position.add(t.velocity.clone().multiplyScalar(o)),t.data.isColliding=!0,t.acceleration.push(this.antiGravity))}_step(o){this.applyCollisions(o);for(const t of this.objects)t.fixed||this.applyDynamics(o,t)}stepFixedDt(){const t=Date.now()/1e3;v=t-g,g=t,this._step(.01),this.t+=.01,this.reporter&&this.reporter({...this,frameTime:v})}stepAccumulator(){const o=this.dt,t=Date.now()/1e3;g===0&&(g=t),v=t-g,g=t,b+=v;let s=0;for(;b>=o&&s<5;)s++,this._step(o),b-=o,this.t+=o,this.reporter&&this.reporter({...this,frameTime:v})}step(){this.stepAccumulator()}}let g=0,v=0,b=0;const L=e=>{var o,t;return{geometry:e.geometry,m:e.mass??1,position:((o=e.position)==null?void 0:o.clone())??new d(0,0),velocity:((t=e.velocity)==null?void 0:t.clone())??new d(0,0),acceleration:[],restitution:e.restitution??.9,friction:e.friction??.4,fixed:e.fixed??!1,data:{isColliding:!1}}};export{F as W,L as c};
