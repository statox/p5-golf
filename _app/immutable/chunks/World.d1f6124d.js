var F=Object.defineProperty;var _=(f,o,t)=>o in f?F(f,o,{enumerable:!0,configurable:!0,writable:!0,value:t}):f[o]=t;var c=(f,o,t)=>(_(f,typeof o!="symbol"?o+"":o,t),t);import{V as u}from"./PhysicObject.d0894205.js";class z{constructor(){c(this,"apply",(o,t)=>{const i=this.bounce(o,t),n=this.pullApart(o,t);return{...i,...n}});c(this,"intersectionPoint",(o,t)=>{if(t.geometry.type!=="sphere"||o.geometry.type!=="line")throw new Error("invalid geometry");const i=o.position.clone(),n=o.position.clone().add(o.geometry.vector),s=t.position.clone(),r=t.geometry.r,e=n.clone().subtract(i),l=i.clone().subtract(s),y=e.dot(e),d=l.dot(e)*2,v=l.dot(l)-r*r;let m=d*d-4*y*v;if(m<0)return;m=Math.sqrt(m);const h=(-d-m)/(2*y),a=(-d+m)/(2*y),p=h>=0&&h<=1,w=a>=0&&a<=1;if(p&&w)return i.add(e.multiplyScalar(h+(a-h)*.5));if(p)return i.add(e.multiplyScalar(1));if(w)return i.add(e.multiplyScalar(0))});c(this,"bounce",(o,t)=>{if(t.geometry.type!=="sphere"||o.geometry.type!=="line")throw new Error("invalid geometry");const i=this.intersectionPoint(o,t);if(!i)return;const n=o.restitution*t.restitution,s=o.friction*t.friction,r=o.position.x,e=o.position.y,l=o.position.x+o.geometry.vector.x,y=o.position.y+o.geometry.vector.y,d=t.position.x,v=t.position.y,m=t.position.x+t.velocity.x,h=t.position.y+t.velocity.y;let a=(y-e)/(l-r),p=(h-v)/(m-d);if(a=[1/0,-1/0].includes(a)?360:a,p=[1/0,-1/0].includes(p)?360:p,(a-p)/(1+a*p)===0){const L=n,q=s;return{bouncedVelocity:t.velocity.multiplyScalar(1-q).multiplyScalar(-L),intersection:i}}const x=l-r,V=y-e,E=new u(-V,x),j=new u(V,-x),G=i.clone().add(E),A=i.clone().add(j);let S;t.position.distanceSq(G)<t.position.distanceSq(A)?S=E:S=j;const T=S.clone().normalize(),W=t.velocity.clone(),D=T.multiplyScalar(W.dot(T)),N=W.subtract(D),P=n,I=s;return{bouncedVelocity:N.multiplyScalar(1-I).subtract(D.multiplyScalar(P)),intersection:i}});c(this,"pullApart",(o,t)=>{if(t.geometry.type!=="sphere"||o.geometry.type!=="line")throw new Error("invalid geometry");const i=this.intersectionPoint(o,t);if(!i)return;const n=t.position.clone().subtract(i),s=n.length();if(s>t.geometry.r)return{positionCorrection:new u(0,0)};const e=t.geometry.r-s;return{positionCorrection:n.normalize().multiplyScalar(e)}})}}const k=new z;class J{constructor(o){c(this,"gravityEnabled");c(this,"dimensions");c(this,"t");c(this,"objects");c(this,"gravity",new u(0,-9.8));c(this,"antiGravity",new u(0,9.8));c(this,"drag",.001);c(this,"dt",.005);c(this,"reporter");this.gravityEnabled=o.enableGravity??!0,this.dimensions=o.dimensions||new u(100,100),this.objects=[],this.t=0,this.reporter=o.reporter||console.log}toggleGravity(){this.gravityEnabled=!this.gravityEnabled}addObject(o){this.objects.push(o)}applyGravity(o){o.acceleration.push(this.gravity)}applyForce(o,t){o.acceleration.push(t)}applyDynamics(o,t){if(t.fixed)return;this.gravityEnabled&&this.applyGravity(t);const i=new u(0,0);for(;t.acceleration.length;){const s=t.acceleration.pop();s&&i.add(s)}i.divideScalar(t.m);const n=1-this.drag;t.velocity.add(i.multiplyScalar(o)).multiplyScalar(n),t.position.add(t.velocity.clone().multiplyScalar(o))}applyCollisions(o){const t=this.objects.filter(n=>n.geometry.type==="sphere"),i=this.objects.filter(n=>n.geometry.type==="line");for(const n of t){n.data.isColliding=!1;const s=new u(0,0);let r=0;for(const e of i){e.data.isColliding=!1;const l=k.apply(e,n);if(!l.intersection)continue;const{bouncedVelocity:y,positionCorrection:d}=l;e.data.isColliding=!0,e.collisionListener(),r++,s.add(y),n.position.add(d)}r>0&&(s.divideScalar(r),n.velocity.copy(s),n.position.add(n.velocity.clone().multiplyScalar(o)),n.data.isColliding=!0,n.collisionListener(),n.acceleration.push(this.antiGravity))}}_step(o){this.applyCollisions(o);for(const t of this.objects)this.applyDynamics(o,t)}stepFixedDt(){const t=Date.now()/1e3;b=t-g,g=t,this._step(.01),this.t+=.01,this.reporter&&this.reporter({...this,frameTime:b})}stepAccumulator(){const o=this.dt,t=Date.now()/1e3;g===0&&(g=t),b=t-g,g=t,C+=b;let i=0;for(;C>=o&&i<5;)i++,this._step(o),C-=o,this.t+=o,this.reporter&&this.reporter({...this,frameTime:b})}step(){this.stepAccumulator()}}let g=0,b=0,C=0;export{J as W};
