var P=Object.defineProperty;var _=(e,t,o)=>t in e?P(e,t,{enumerable:!0,configurable:!0,writable:!0,value:o}):e[t]=o;var d=(e,t,o)=>(_(e,typeof t!="symbol"?t+"":t,o),o);import{V as m}from"./PhysicObject.de1d9a18.js";const z=(e,t)=>{if(t.geometry.type!=="sphere"||e.geometry.type!=="line")throw new Error("invalid geometry");const o=A(e,t);if(!o)return;const n=e.restitution*t.restitution,i=e.friction*t.friction,c=e.position.x,s=e.position.y,l=e.position.x+e.geometry.vector.x,p=e.position.y+e.geometry.vector.y,f=t.position.x,g=t.position.y,r=t.position.x+t.velocity.x,u=t.position.y+t.velocity.y;let a=(p-s)/(l-c),y=(u-g)/(r-f);if(a=[1/0,-1/0].includes(a)?360:a,y=[1/0,-1/0].includes(y)?360:y,(a-y)/(1+a*y)===0){const q=n,F=i;return{bouncedVelocity:t.velocity.multiplyScalar(1-F).multiplyScalar(-q),intersection:o}}const x=l-c,C=p-s,V=new m(-C,x),E=new m(C,-x),D=o.clone().add(V),G=o.clone().add(E);let w;t.position.distanceSq(D)<t.position.distanceSq(G)?w=V:w=E;const j=w.clone().normalize(),T=t.velocity.clone(),W=j.multiplyScalar(T.dot(j)),I=T.subtract(W),L=n,N=i;return{bouncedVelocity:I.multiplyScalar(1-N).subtract(W.multiplyScalar(L)),intersection:o}},A=(e,t)=>{if(t.geometry.type!=="sphere"||e.geometry.type!=="line")throw new Error("invalid geometry");const o=e.position.clone(),n=e.position.clone().add(e.geometry.vector),i=t.position.clone(),c=t.geometry.r,s=n.clone().subtract(o),l=o.clone().subtract(i),p=s.dot(s),f=l.dot(s)*2,g=l.dot(l)-c*c;let r=f*f-4*p*g;if(r<0)return;r=Math.sqrt(r);const u=(-f-r)/(2*p),a=(-f+r)/(2*p),y=u>=0&&u<=1,b=a>=0&&a<=1;if(y&&b)return o.add(s.multiplyScalar(u+(a-u)*.5));if(y)return o.add(s.multiplyScalar(1));if(b)return o.add(s.multiplyScalar(0))};class H{constructor(t){d(this,"gravityEnabled");d(this,"dimensions");d(this,"t");d(this,"objects");d(this,"gravity",new m(0,-9.8));d(this,"antiGravity",new m(0,9.8));d(this,"drag",.001);d(this,"dt",.005);d(this,"reporter");this.gravityEnabled=t.enableGravity??!0,this.dimensions=t.dimensions||new m(100,100),this.objects=[],this.t=0,this.reporter=t.reporter||console.log}toggleGravity(){this.gravityEnabled=!this.gravityEnabled}addObject(t){this.objects.push(t)}applyGravity(t){t.acceleration.push(this.gravity)}applyForce(t,o){t.acceleration.push(o)}applyDynamics(t,o){if(o.fixed)return;this.gravityEnabled&&this.applyGravity(o);const n=new m(0,0);for(;o.acceleration.length;){const c=o.acceleration.pop();c&&n.add(c)}n.divideScalar(o.m);const i=1-this.drag;o.velocity.add(n.multiplyScalar(t)).multiplyScalar(i),o.position.add(o.velocity.clone().multiplyScalar(t))}applyCollisions(t){const o=this.objects.filter(i=>i.geometry.type==="sphere"),n=this.objects.filter(i=>i.geometry.type==="line");for(const i of o){i.data.isColliding=!1;const c=new m(0,0);let s=0;for(const l of n){l.data.isColliding=!1;const p=z(l,i);if(!p)continue;const{bouncedVelocity:f,intersection:g}=p;l.data.isColliding=!0,l.collisionListener(),s++,c.add(f);const r=i.position.clone().subtract(g),u=r.length();if(u<=i.geometry.r){const y=i.geometry.r-u;r.normalize().multiplyScalar(y),i.position.add(r)}}s>0&&(c.divideScalar(s),i.velocity.copy(c),i.position.add(i.velocity.clone().multiplyScalar(t)),i.data.isColliding=!0,i.collisionListener(),i.acceleration.push(this.antiGravity))}}_step(t){this.applyCollisions(t);for(const o of this.objects)this.applyDynamics(t,o)}stepFixedDt(){const o=Date.now()/1e3;v=o-h,h=o,this._step(.01),this.t+=.01,this.reporter&&this.reporter({...this,frameTime:v})}stepAccumulator(){const t=this.dt,o=Date.now()/1e3;h===0&&(h=o),v=o-h,h=o,S+=v;let n=0;for(;S>=t&&n<5;)n++,this._step(t),S-=t,this.t+=t,this.reporter&&this.reporter({...this,frameTime:v})}step(){this.stepAccumulator()}}let h=0,v=0,S=0;export{H as W};
